#! /usr/bin/env Rscript
###############################################################################
# PEPPRO R parser

###############################################################################
version <- 0.6
##### Load dependencies #####

required_libraries <- c("PEPPROr")
for (i in required_libraries) {
    loadLibrary <- tryCatch (
        {
            suppressPackageStartupMessages(
                suppressWarnings(library(i, character.only=TRUE)))
        },
        error=function(e) {
            message("Error: Install the \"", i,
                    "\" R package before proceeding.")
            message('i.e. devtools::install_github("databio/peppro",',
                    ' subdir="PEPPROr")')
            return(NULL)
        },
        warning=function(e) {
            message(e)
            return(1)
        }
    )
    if (length(loadLibrary)!=0) {
        suppressWarnings(library(i, character.only=TRUE))
    } else {
        quit()
    }
}

###############################################################################

#### Identify command ####

subcmd <- opt_get_verb()

if (is.na(subcmd) || grepl("/R", subcmd)) {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: preseq\t\t plot preseq complexity curves\n",
        "\t frif\t\t plot fraction of reads in features\n",
        "\t tss\t\t plot TSS enrichment\n",
        "\t frag\t\t plot PE fragment length distribution\n",
        "\t mrna\t\t plot mRNA contamination distribution\n",
        "\t pi\t\t plot pause indicies distribution\n",
        "\t cutadapt\t plot cutadapt-based adapter insertion distribution\n",
        "\t adapt\t plot generalized adapter insertion distribution\n"
    )
    message(usage)
} else if (!is.na(subcmd) && tolower(subcmd) == "preseq") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: preseq \t plot preseq complexity curves\n\n",
        " -i, --input\t\t Input files generated by preseq.\n",
        " -c, --coverage\t\t Use coverage on axes instead of read counts. ",
                               "Enter number of base pairs of reference.\n",
        " -l, --read_length\t Sequence read length, for use in coverage ",
                               "calculations.\n",
        " -r, --real_counts\t File name for file with three columns - ",
                               "preseq filename, total number reads, number",
                               " of unique reads (unique optional, ",
                               "whitespace delimited)\n",
        " -u, --ignore_unique\t Ignore any information about unique read ",
                               "counts found in --real_counts file.\n",
        " -o, --output_name\t Output name (.png/.pdf will be automatically ",
                               "added). Default: 'complexity_curves'.\n",
        " -m, --x_min\t\t Lower x-limit (default 0).\n",
        " -x, --x_max\t\t Upper x-limit (default 500 million).\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        # get arguments
        a       <- opt_get_args()

        # Determine the number of input files
        inArgs  <- 0
        argList <- c("-c", "-l", "-r", "-u", "-o", "-m", "-x",
                     "--coverage", "--read_length", "--real_counts",
                     "--ignore_unique", "--output_name", "--x_min", "--x_max")
        p       <- 1
        val     <- a[p]
        while (!(val %in% c("-i", "--input"))) {
            p   <- p + 1
            val <- a[p]
        }
        while (!(val %in% argList) && p < length(opt_get_args())) {
            p   <- p + 1
            val <- a[p]
            if (!(val %in% argList)) {
                inArgs <- inArgs + 1
            }
        }

        # Determine the number of real counts files
        cArgs   <- 0
        argList <- c("-i", "-c", "-l", "-u", "-o", "-m", "-x",
                     "--input", "--coverage", "--read_length",
                     "--ignore_unique", "--output_name", "--x_min", "--x_max")
        p       <- 1
        val     <- a[p]
        while (!(val %in% c("-r", "--real_counts"))) {
            p   <- p + 1
            val <- a[p]
        }
        while (!(val %in% argList) && p < length(opt_get_args())) {
            p   <- p + 1
            val <- a[p]
            if (!(val %in% argList)) {
                cArgs <- cArgs + 1
            }
        }
        input       <- opt_get(name = c("input", "i"), required=TRUE,
                               n=inArgs,
                               description="Input files generated by preseq.")
        cov_help    <- paste0("Use coverage on axes instead of read ",
                              "counts. Enter number of base pairs of reference.")
        coverage    <- opt_get(name = c("coverage", "c"), required=FALSE,
                               default=0, description=cov_help)
        rl_help     <- paste0("Sequence read length, for use in coverage",
                              " calculations")
        read_length <- opt_get(name = c("read_length", "l"), required=FALSE,
                               default=0, description=rl_help)
        rc_help     <- paste0("File name for file with three columns - ",
                              "preseq filename, total number reads, number of ",
                              "unique reads (unique optional, whitespace ",
                              "delimited)")
        real_counts <- opt_get(name = c("real_counts", "r"), required=FALSE,
                               n=cArgs, description=rc_help)
        uni_help    <- paste0("Ignore any information about unique read ",
                              "counts found in --real_counts file.")
        ign_unique  <- opt_get(name = c("ignore_unique", "u"), required=FALSE,
                               default=FALSE, description=uni_help)
        output_help <- "Output name (.png/.pdf will be automatically added)"
        output_name <- opt_get(name=c("o", "output_name"), required=FALSE,
                               default='complexity_curves',
                               description=output_help)
        x_min       <- opt_get(name=c("m", "x_min"),
                               required=FALSE, default=0,
                               description="Lower x-limit (default 0)")
        x_max       <- opt_get(name=c("x", "x_max"),
                               required=FALSE, default=500000000,
                               description="Upper x-limit (default 500 million)")

        p <- PEPPROr::plotComplexityCurves(ccurves = input,
                                           coverage = coverage,
                                           read_length = read_length,
                                           real_counts_path = real_counts,
                                           ignore_unique = ign_unique,
                                           x_min = x_min,
                                           x_max = x_max)

        if (length(input) == 1) {
            # now save the plot
            pdf(file = paste0(tools::file_path_sans_ext(output_name), ".pdf"),
                height = 4, width = 4.25, useDingbats=F)
            suppressWarnings(print(p))
            invisible(dev.off())

            png(filename = paste0(tools::file_path_sans_ext(output_name), ".png"),
                height = 275, width = 300)
            suppressWarnings(print(p))
            invisible(dev.off())
        } else {
            # now save the plot
            pdf(file = paste0(tools::file_path_sans_ext(output_name), ".pdf"),
                height = 5, width = 6, useDingbats=F)
            suppressWarnings(print(p))
            invisible(dev.off())

            png(filename = paste0(tools::file_path_sans_ext(output_name), ".png"),
                height = 315, width = 425)
            suppressWarnings(print(p))
            invisible(dev.off())
        }

        if (exists("p")) {
            write("Library complexity plot completed!\n", stdout())
        } else {
            write("Unable to produce library complexity plot!\n", stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "frif") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: frif \t plot fraction of reads in features\n\n",
        " -s, --sample_name\t   Sample name.\n",
        " -n, --num_reads\t\t   Number of mapped reads.\n",
        " -z, --size\t\t   Size of genome (bp).\n",
        " -y, --type\t Choose plot type: cFRiF, FRiF, or Both.\n",
        " -o, --output_name\t   Output file name.\n",
        " -b, --bed\t\t   Coverage file(s).\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        sample_name <- opt_get(name = c("sample_name", "s"), required=TRUE,
                               description="Sample name.")
        num_reads   <- opt_get(name = c("num_reads", "n"), required=TRUE,
                               description="Number of mapped reads (or bases).")
        genome_size <- opt_get(name = c("size", "z"), required=TRUE,
                               description="Size of genome (bp).")
        type        <- opt_get(name = c("type", "y"), required=FALSE, default="cfrif",
                               description="Choose plot type: cFRiF, FRiF, or Both (Default = cfrif).")
        reads       <- opt_get(name = c("reads", "r"), required=FALSE, default=FALSE,
                               description="Calculate using reads (TRUE) or bases (FALSE) (Default = FALSE).")
        output_name <- opt_get(name = c("output_name", "o"), required=TRUE,
                               description="Output file name.")
        numArgs     <- length(opt_get_args())
        #message(numArgs)
        argGap      <- ifelse(reads, 13, 12)
        #message(argGap)
        bed         <- opt_get(name = c("bed", "b"), required=TRUE,
                               n=(numArgs - argGap),
                               description="Coverage file(s).")
        #message(paste0("\nbed: ", bed))

        p <- PEPPROr::plotFRiF(sample_name = sample_name,
                               num_reads = as.numeric(num_reads),
                               genome_size = as.numeric(genome_size),
                               type = tolower(type),
                               reads = reads,
                               output_name = output_name,
                               bedFile = bed)

        if (tolower(type) == "both") {
            pdf(file = paste0(tools::file_path_sans_ext(output_name), ".pdf"),
                height = 5.45, width = 8.39, useDingbats=F)
            suppressWarnings(print(p))
            invisible(dev.off())
            png(filename = paste0(tools::file_path_sans_ext(output_name), ".png"),
                height = 550, width=850)
            suppressWarnings(print(p))
            invisible(dev.off())
        } else {
            pdf(file = paste0(tools::file_path_sans_ext(output_name), ".pdf"),
                height = 4, width = 4, useDingbats=F)
            suppressWarnings(print(p))
            invisible(dev.off())
            png(filename = paste0(tools::file_path_sans_ext(output_name), ".png"),
                height = 275, width=275)
            suppressWarnings(print(p))
            invisible(dev.off())
        }
        

        if (exists("p")) {
            write(paste0("Cumulative ", type, " plot completed!\n"), stdout())
        } else {
            write(paste0("Unable to produce ", type, " plot!\n"), stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "tss") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: tss \t plot TSS enrichment\n\n",
        " -i, --input\t TSS enrichment file.\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        TSS_CUTOFF <- 6
        # get arguments
        a   <- opt_get_args()
        # Determine the number of input files
        inArgs <- 0
        p      <- 1
        val    <- a[p]
        while (!(val %in% c("-i", "--input"))) {
            p   <- p + 1
            val <- a[p]
        }
        while (p < length(opt_get_args())) {
            p   <- p + 1
            val <- a[p]
            if (!(val %in% c("-i", "--input"))) {
                inArgs <- inArgs + 1
            }
        }

        TSSfile     <- opt_get(name = c("input", "i"), required=TRUE, n=inArgs,
                               description="TSS enrichment file.")

        p           <- PEPPROr::plotTSS(TSSfile = TSSfile)

        sample_name <- PEPPROr::sampleName(TSSfile[1])

        png(filename = paste0(sample_name, "_TSSenrichment.png"),
            width = 275, height = 275)
        suppressWarnings(print(p))
        invisible(dev.off())

        pdf(file = paste0(sample_name, "_TSSenrichment.pdf"),
            width = 4, height = 4, useDingbats=F)
        suppressWarnings(print(p))
        invisible(dev.off())

        if (exists("p")) {
            write("TSS enrichment plot completed!\n", stdout())
        } else {
            write("Unable to produce TSS enrichment plot!\n", stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "frag") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: frag \t plot fragment length distribution\n\n",
        " -l, --frag_len\t\t Column of fragment lengths.\n",
        " -c, --frag_count\t Counts of each fragment length.\n",
        " -p, --pdf\t\t PDF output file name.\n",
        " -t, --text\t\t Fragment length distribution stats file.\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        fragL       <- opt_get(name = c("frag_len", "l"), required=TRUE,
                               description="Column of fragment lengths.")
        fragL_count <- opt_get(name = c("frag_count", "c"), required=TRUE,
                               description="Counts of each fragment length.")
        fragL_name  <- opt_get(name = c("pdf", "p"), required=TRUE,
                               description="PDF output file name.")
        fragL_txt   <- opt_get(name = c("text", "t"), required=TRUE,
                               description="Fragment length distribution stats file.")

        p <- PEPPROr::plotFLD(fragL = fragL,
                              fragL_count = fragL_count,
                              fragL_txt = fragL_txt)

        # Save plot to pdf file
        pdf(file=fragL_name, width = 4, height = 4, useDingbats=F)
        suppressWarnings(print(p))
        invisible(dev.off())

        # Save plot to png file
        outfile_png <- gsub('pdf', 'png', fragL_name)
        png(filename=outfile_png, width = 275, height = 275)
        suppressWarnings(print(p))
        invisible(dev.off())

        if (exists("p")) {
            write("Fragment distribution plot completed!\n", stdout())
        } else {
            write("Unable to produce fragment distribution plot!\n", stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "mrna") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: mrna \t plot mRNA contamination distribution\n\n",
        " -i, --rpkm\t Three column TSV of intron and exon RPKM by gene.\n",
        " -w, --raw\t Plot raw exon/intron ratios instead of log10.\n",
        " -y, --type\t Choose plot type from: histogram, boxplot, or violin.\n",
        " -a, --annotate\t Display raw and log10-transformed median values on plot.\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        rpkm <- opt_get(name = c("rpkm", "i"), required=TRUE,
                        description="Three column TSV containing gene exon and intron RPKMs.")
        raw  <- opt_get(name = c("raw", "w"), required=FALSE, default=FALSE,
                        description="Plot raw ratios (Default = FALSE).")
        type <- opt_get(name = c("type", "y"), required=FALSE, default="histogram",
                        description="Choose plot type from: histogram, boxplot, or violin (Default = histogram).")
        annotate <- opt_get(name = c("annotate", "a"), required=FALSE, default=FALSE,
                            description="Display raw and log10-transformed median values on plot.")

        sample_name        <- PEPPROr::sampleName(rpkm, 3)
        name               <- basename(sample_name)
        suppressWarnings(p <- PEPPROr::mRNAcontamination(rpkm=rpkm, name=name,
                                                         raw=raw,
                                                         type=tolower(type),
                                                         annotate=annotate))

        # Save plot to pdf file
        pdf(file=paste0(sample_name, "_mRNA_contamination.pdf"),
            width = 4, height = 4, useDingbats=F)
        suppressMessages(suppressWarnings(print(p)))
        invisible(dev.off())
             
        # Save plot to png file
        png(filename = paste0(sample_name, "_mRNA_contamination.png"),
            width = 275, height = 275)
        suppressMessages(suppressWarnings(print(p)))
        invisible(dev.off())

        if (exists("p")) {
            write("mRNA contamination plot completed!\n", stdout())
        } else {
            write("Unable to produce mRNA contamination plot!\n", stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "pi") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: pi \t plot pause indicies distribution\n\n",
        " -i, --input\t Pause density/gene body density ratios.\n",
        " -w, --raw\t Plot raw exon/intron ratios instead of log10.\n",
        " -y, --type\t Choose plot type from: histogram, boxplot, or violin.\n",
        " -a, --annotate\t Display median and mean values on plot.\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        input <- opt_get(name = c("input", "i"), required=TRUE,
                         description="Pause density/gene body density ratios.")
        raw   <- opt_get(name = c("raw", "w"), required=FALSE, default=FALSE,
                         description="Plot raw ratios (Default = FALSE).")
        type  <- opt_get(name = c("type", "y"), required=FALSE, default="histogram",
                         description="Choose plot type from: histogram, boxplot, or violin (Default = histogram).")
        annotate <- opt_get(name = c("annotate", "a"), required=FALSE, default=FALSE,
                            description="Display median and mean values on plot.")

        sample_name        <- sampleName(input)
        name               <- basename(sample_name)
        suppressWarnings(p <- PEPPROr::plotPI(pi=input, name=name, raw=raw,
                                              type=tolower(type),
                                              annotate=annotate))

        # Save plot to pdf file
        pdf(file=paste0(sample_name, "_pause_index.pdf"),
            width = 4, height = 4, useDingbats=F)
        suppressWarnings(print(p))
        invisible(dev.off())
             
        # Save plot to png file
        png(filename = paste0(sample_name, "_pause_index.png"),
            width = 275, height = 275)
        suppressWarnings(print(p))
        invisible(dev.off())

        if (exists("p")) {
            write("Pause index plot completed!\n", stdout())
        } else {
            write("Unable to produce pause index plot!\n", stdout())
        }
    }
} else if (!is.na(subcmd) && tolower(subcmd) == "cutadapt") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: cutadapt \t plot cutadapt-based adapter insertion distribution\n\n",
        " -i, --input\t cutadapt report.\n",
        " -o, --output\t output directory.\n",
        " -u, --umi_len\t UMI length (Default 0).\n",
        " -f, --factor\t Factor to divide read count (Default 1M).\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        input   <- opt_get(name = c("input", "i"), required=TRUE,
                           description="cutadapt report.")
        output  <- opt_get(name = c("output", "o"), required=TRUE,
                           description="output destination directory.")
        umi_len <- opt_get(name = c("umi_len", "u"), required=FALSE,
                           default = 0,
                           description="UMI length (Default 0).")
        factor  <- opt_get(name = c("factor", "f"), required=FALSE,
                           default = 1000000,
                           description="Factor to divide read count (Default 1M).")

        name               <- basename(sampleName(input, num_fields=1))
        #message(name)
        suppressWarnings(p <- PEPPROr::plotCutadapt(input=input, name=name,
                                                    umi_len = umi_len,
                                                    count_factor=factor))
        sample_name        <- paste(output, name, sep="/")
        #message(sample_name)

        # Save plot to pdf file
        pdf(file=paste0(sample_name, "_adapter_insertion_distribution.pdf"),
            width = 4, height = 4, useDingbats=F)
        suppressWarnings(print(p))
        invisible(dev.off())
             
        # Save plot to png file
        png(filename = paste0(sample_name,
                              "_adapter_insertion_distribution.png"),
            width = 275, height = 275)
        suppressWarnings(print(p))
        invisible(dev.off())

        if (exists("p")) {
            write("Adapter insertion distribution plot completed!\n", stdout())
        } else {
            write("Unable to produce adapter insertion distribution plot!\n",
                  stdout())
        }
    }
}  else if (!is.na(subcmd) && tolower(subcmd) == "adapt") {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: adapt \t plot generalized adapter insertion distribution\n\n",
        " -i, --input\t flash histogram output.\n",
        " -o, --output\t output directory.\n",
        " -u, --umi_len\t UMI length (Default 0).\n"
    )

    help <- opt_get(name = c("help", "?", "h"), required=FALSE,
                    default=FALSE, n=0)
    if (!help) {
        help <- suppressWarnings(
            if(length(opt_get_args()) == 1) {TRUE} else {FALSE}
        )
    }
    if (help) {
        message(usage)
        quit()
    } else {
        input   <- opt_get(name = c("input", "i"), required=TRUE,
                           description="flash histogram output.")
        output  <- opt_get(name = c("output", "o"), required=TRUE,
                           description="output destination directory.")
        umi_len <- opt_get(name = c("umi_len", "u"), required=FALSE,
                           default = 0,
                           description="UMI length (Default 0).")

        name               <- basename(PEPPROr::sampleName(input, num_fields=0))
        #message(name)
        suppressWarnings(p <- PEPPROr::plotAdapt(input=input, name=name,
                                                 umi_len = umi_len))
        sample_name        <- paste(output, name, sep="/")
        #message(sample_name)

        # Save plot to pdf file
        pdf(file=paste0(sample_name, "_adapter_insertion_distribution.pdf"),
            width = 4, height = 4, useDingbats=F)
        suppressWarnings(print(p))
        invisible(dev.off())
             
        # Save plot to png file
        png(filename = paste0(sample_name,
                              "_adapter_insertion_distribution.png"),
            width = 275, height = 275)
        suppressWarnings(print(p))
        invisible(dev.off())

        if (exists("p")) {
            write("Adapter insertion distribution plot completed!\n", stdout())
        } else {
            write("Unable to produce adapter insertion distribution plot!\n",
                  stdout())
        }
    }
} else {
    usage <- paste0(
        "\n",
        "Usage:   PEPPRO.R [command] {args}\n",
        "Version: ", version, "\n\n",
        "Command: preseq\t\t plot preseq complexity curves\n",
        "\t frif\t\t plot fraction of reads in features\n",
        "\t tss\t\t plot TSS enrichment\n",
        "\t frag\t\t plot PE fragment length distribution\n",
        "\t mrna\t\t plot mRNA contamination distribution\n",
        "\t pi\t\t plot pause indicies distribution\n",
        "\t cutadapt\t plot cutadapt-based adapter insertion distribution\n",
        "\t adapt\t plot generalized adapter insertion distribution\n"
    )
    message(usage)
    quit()
}
