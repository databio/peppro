#! /usr/bin/env Rscript
###############################################################################
#5/29/2019
#Adapted from https://github.com/ewels/ngi_visualizations/tree/master/ngi_visualizations/preseq_complexity_curves
#preseq_plot.R
#
#This program is meant to generate complexity plots from preseq results
#
#NOTES:
#usage: Rscript /path/to/Rscript/preseq_plot.R
#               ccurve
#
#requirements: argparser, data.table, ggplot2
#
###############################################################################
# LOAD ARGUMENTPARSER
loadLibrary <- tryCatch (
    {
        suppressWarnings(suppressPackageStartupMessages(library(argparser)))
    },
    error=function(e) {
        message("Error: Install the \"argparser\"",
                " library before proceeding.")
        return(NULL)
    },
    warning=function(e) {
        message(e)
        return(TRUE)
    }
)
if (length(loadLibrary)!=0) {
    suppressWarnings(library(argparser))
} else {
    quit()
}

# Create a parser
p <- arg_parser("Plot complexity curves")

# Add command line arguments
p <- add_argument(p, arg='ccurves', 
                  help="Input file generated by preseq.")
p <- add_argument(p, short='-i', arg='--more_ccurves', nargs=Inf, default=NULL,
                  help="Additional preseq input files to plot together.")
p <- add_argument(p, short='-c', arg='--coverage',
                  default=0,
                  help=paste0("Use coverage on axes instead of read ",
                              "counts. Enter number of base pairs of reference."))
p <- add_argument(p, short='-l', arg='--read_length', default=0,
                  help=paste0("Sequence read length, for use in coverage",
                              " calculations"))
p <- add_argument(p, short='-r', arg='--real_counts', default=NULL,
                  help=paste0("File name for file with three columns - ",
                              "preseq filename, total number reads, number of ",
                              "unique reads (unique optional, whitespace ",
                              "delimited)"))
p <- add_argument(p, short='-u', arg='--ignore_unique',
                  flag=TRUE, default=FALSE,
                  help=paste0("Ignore any information about unique read ",
                              "counts found in --real-counts file."))
p <- add_argument(p, short='-o', arg='--output_name',
                  default='complexity_curves',
                  help="Output name (.png will be automatically added)")
p <- add_argument(p, short='-m', arg='--x_min', default=0,
                  help="Lower x-limit (default 0)")
p <- add_argument(p, short='-x', arg='--x_max', default=500000000,
                  help="Upper x-limit (default 500 million)")

# Parse the command line arguments
argv <- parse_args(p)

###############################################################################

##### LOAD DEPENDENCIES #####
required_libraries <- c("data.table", "ggplot2")
for (i in required_libraries) {
    loadLibrary <- tryCatch (
        {
            suppressPackageStartupMessages(
                suppressWarnings(library(i, character.only=TRUE)))
        },
        error=function(e) {
            message("Error: Install the \"", i,
                    "\" library before proceeding.")
            return(NULL)
        },
        warning=function(e) {
            message(e)
            return(1)
        }
    )
    if (length(loadLibrary)!=0) {
        suppressWarnings(library(i, character.only=TRUE))
    } else {
        quit()
    }
}

###############################################################################
# FUNCTIONS

plot_complexity_curves <- function(ccurves, more_ccurves,
                                   coverage=0, read_length=0,
                                   real_counts_path=FALSE, use_unique=TRUE,
                                   output_name='complexity_curves',
                                   x_min=0, x_max=500000000) {
    
    if (x_min < 0 || x_max <= x_min) {
        message(paste0("problem with x-min or x-max (", x_min, " ", x_max,
                       "). x-min must be >= 0 and < x-max"))
        quit()
    }
    
    # Convert limit counts to coverage
    if (coverage > 0 && read_length == 0) {
        message("Error: --coverage specified but not --read_length")
        quit()
    } else {
        coverage <- as.numeric(coverage) / as.numeric(read_length)
        x_max    <- as.numeric(x_max) / coverage
        x_min    <- as.numeric(x_min) / coverage
        
        # Get the real counts if we have them
        real_counts_total  <- 0
        real_counts_unique <- 0
        real_counts_name   <- character()
        info <- file.info(file.path(real_counts_path))
        if (file.exists(real_counts_path) && info$size != 0) {
            rc_file <- fread(real_counts_path)
            real_counts_name   <- basename(rc_file$V1)
            real_counts_total  <- as.integer(rc_file$V2)
            if (ncol(rc_file) == 3 && use_unique) {
                real_counts_unique <- as.integer(rc_file$V3)
            }
        } else {
            message(paste0("Error loading real counts file: ", real_counts_path))
            if (!file.exists(real_counts_path)) {
                message("File could not be found.")
            } else if (info$size == 0) {
                message("File is empty.")
            }
            quit()
        }
        
        # Convert real counts to coverage
        if (coverage > 0) {
            real_counts_total  <- as.numeric(real_counts_total)  / coverage
            real_counts_unique <- as.numeric(real_counts_unique) / coverage
        }
        
        # Set up plot params
        global_x_max_ccurve_limit <- 0
        global_y_max_ccurve_limit <- 0
        fig <- ggplot()
        max_label_length <- 0
        
        # Each ccurve will get a different color
        palette <- colorRampPalette(c("#999999", "#FFC107", "#27C6AB", "#004D40",
                                      "#B97BC8", "#009E73", "#C92404", "#E3E550",
                                      "#372B4C", "#E3DAC7", "#27CAE6", "#B361BC",
                                      "#897779", "#6114F8", "#19C42B", "#56B4E9"))
        
        clist <- data.table(TOTAL_READS = list(), EXPECTED_DISTINCT = list())
        # Go through inputs and plot line
        if (!is.na(more_ccurves)) {
            ccurves <- list(ccurves, more_ccurves)
        } else {
            ccurves <- list(ccurves)
        }
        colormap <- palette(length(ccurves))
        for (c in 1:length(ccurves)) {
            message(paste0("c: ", c))
            name        <- basename(tools::file_path_sans_ext(ccurves[[c]]))
            numFields   <- 2
            for(j in 1:numFields) name <- gsub("_[^_]*$", "", name)
            sample_name <- name
            message(paste0("Processing ", sample_name))
            ctable <- fread(ccurves[[c]])
            if (coverage > 0) {
                if ("TOTAL_READS" %in% colnames(ctable)) {
                    ccurve_TOTAL_READS <- as.numeric(ctable$TOTAL_READS) / coverage
                } else if ("total_reads" %in% colnames(ctable)) {
                    ccurve_TOTAL_READS <- as.numeric(ctable$total_reads) / coverage
                }
                if ("EXPECTED_DISTINCT" %in% colnames(ctable)) {
                    ccurve_EXPECTED_DISTINCT <- as.numeric(ctable$EXPECTED_DISTINCT) / coverage
                } else if ("distinct_reads" %in% colnames(ctable)) {
                    ccurve_EXPECTED_DISTINCT <- as.numeric(ctable$distinct_reads) / coverage
                } else {
                    messsage(paste0("Error, table ", c, " is not in the expected "))
                    message("format... has it been generated with preseq?")
                    quit()
                }
            } else {
                if ("TOTAL_READS" %in% colnames(ctable)) {
                    ccurve_TOTAL_READS <- ctable$TOTAL_READS
                } else if ("total_reads" %in% colnames(ctable)) {
                    ccurve_TOTAL_READS <- ctable$total_reads
                }
                if ("EXPECTED_DISTINCT" %in% colnames(ctable)) {
                    ccurve_EXPECTED_DISTINCT <- ctable$EXPECTED_DISTINCT
                } else if ("distinct_reads" %in% colnames(ctable)) {
                    ccurve_EXPECTED_DISTINCT <- ctable$distinct_reads
                } else {
                    messsage(paste0("Error, table ", c, " is not in the expected "))
                    message("format... has it been generated with preseq?")
                    quit()
                }
            }
            if (c == 1) {
                clist <- data.table(TOTAL_READS = list(ccurve_TOTAL_READS),
                                    EXPECTED_DISTINCT = list(ccurve_EXPECTED_DISTINCT))
            } else {
                clist <- rbindlist(list(clist,
                                        data.table(TOTAL_READS = list(ccurve_TOTAL_READS),
                                                   EXPECTED_DISTINCT = list(ccurve_EXPECTED_DISTINCT))),
                                   use.names=TRUE)
            }
            # ggplot(ctable, aes(rep(1:10000), EXPECTED_DISTINCT)) +
            #     geom_point() +
            #     geom_point(aes(rep(1:10000), TOTAL_READS, col='red')) +
            #     scale_y_continuous(limits=c(0,75000000)) +
            #     scale_x_continuous(limits=c(0,1000))
            
            # ggplot(ctable, aes(rep(1:10000), EXPECTED_DISTINCT/coverage)) +
            #     geom_point() +
            #     geom_point(aes(rep(1:10000), TOTAL_READS/coverage, col='red')) +
            #     scale_y_continuous(limits=c(0,75000000/coverage)) +
            #     scale_x_continuous(limits=c(1,501))
            
            x_min_ccurve_limit <- computeLimit(x_min, ccurve_TOTAL_READS)
            x_max_ccurve_limit <- computeLimit(x_max, ccurve_TOTAL_READS)
            if (x_max_ccurve_limit > global_x_max_ccurve_limit) {
                global_x_max_ccurve_limit <- x_max_ccurve_limit
            }
            if (ccurve_EXPECTED_DISTINCT[x_max_ccurve_limit] > global_y_max_ccurve_limit) {
                if (x_max_ccurve_limit <= length(ccurve_EXPECTED_DISTINCT)) {
                    global_y_max_ccurve_limit <- ccurve_EXPECTED_DISTINCT[x_max_ccurve_limit]
                } else {
                    x_max_ccurve_limit <- length(ccurve_EXPECTED_DISTINCT)
                }
            }
            # Add a few points to be sure
            x_max_ccurve_limit <- x_max_ccurve_limit + 3 
            
            # Plot the curve
            fig <- ggplot() +
                geom_line(aes(ccurve_TOTAL_READS[x_min_ccurve_limit:x_max_ccurve_limit],
                              ccurve_EXPECTED_DISTINCT[x_min_ccurve_limit:x_max_ccurve_limit],
                              col=colormap[c]))
            
            # Plot the real data if we have it
            if (real_counts_total > 0 && real_counts_unique > 0) {
                fig <- fig +
                    geom_point(aes(real_counts_total,
                                   real_counts_unique,
                                   col=colormap[c]),
                               shape=23, size=3)
                message(paste0("INFO: Found real counts for ", sample_name, 
                               " - Total: ", real_counts_total, " Unique: ",
                               real_counts_unique))
            } else if (real_counts_total > 0) {
                ggp <- ggplot_build(fig)
                xvalues <- ggp$layout$panel_scales_x[[1]]$range$range
                yvalues <- ggp$layout$panel_scales_y[[1]]$range$range
                if (real_counts_total > max(xvalues)) {
                    message(paste0("WARNING: Total reads for ",  sample_name,
                                   "(", real_counts_total,
                                   ") > max preseq value (", max(xvalues),
                                   ") - skipping this point..."))
                }
                else {
                    interp <- approx(xvalues, yvalues, real_counts_total)$y
                    fig <- fig + geom_point(aes(real_counts_total, interp, col=colormap[c]))
                    message(paste0("INFO: Found real count for ", 
                                   sample_name, " - Total: ",
                                   real_counts_total, "(preseq unique reads: ",
                                   interp, ")"))
                }
            } else {
                message(paste0("INFO: No real counts found for ", sample_name))
            }
            
            # plot perfect library as dashed line
            fig <- fig + geom_segment(aes(x = 0, xend=x_max, y=0, yend=x_max), linetype=2)
            
            # Set the axis limits
            max_total <- 0
            if (length(real_counts_total) > 0) {
                max_total <- as.integer(max(real_counts_total))
            }
            
            if (x_max < max_total) {
                message(paste0("WARNING: x-max value ", x_max,
                               " is less than max real data ", max_total))
            }
            
            max_unique <- 0
            if (length(real_counts_unique) > 0) {
                max_unique <- as.integer(max(real_counts_unique))
                max_unique <- max_unique + (max_unique * 0.1)
            }
            preseq_ymax <- global_y_max_ccurve_limit
            preseq_ymax <- preseq_ymax + (global_y_max_ccurve_limit * 0.1)
            
            default_ylim <- 100000
            if (coverage > 0) {
                default_ylim <- as.numeric(default_ylim) / coverage
            }
            fig <- fig +
                coord_cartesian(xlim=c(x_min, x_max),
                                ylim = c(default_ylim,
                                         max(preseq_ymax, max_unique)))
            
            if (preseq_ymax < max_unique) {
                message(paste0("WARNING: y-max value changed from default ",
                               int(preseq_ymax), " to the max real data ",
                               max_unique))
            }
            
            # label the axis
            # Change labels if we're using coverage
            if (coverage > 0) {
                if (length(real_counts_unique) > 0) {
                    fig <- fig +
                        xlab(paste0("Total Coverage (incl. duplicates)\n",
                                    "Points show read count versus deduplicated read counts (externally calculated)"))
                } else if (length(real_counts_total) > 0) {
                    fig <- fig +
                        xlab(paste0("Total Coverage (incl. duplicates)\n",
                                    "Points show externally calculated read counts on the curves"))
                }
                fig <- fig +
                    ylab("Unique Coverage") + 
                    ggtitle("Complexity Curve: preseq")
            } else {
                if (length(real_counts_unique) > 0) {
                    fig <- fig +
                        xlab(paste0("Total Molecules (incl. duplicates)\n",
                                    "Points show read count versus deduplicated read counts (externally calculated)"))
                } else if (length(real_counts_total) > 0) {
                    fig <- fig +
                        xlab(paste0("Total Molecules (incl. duplicates)\n",
                                    "Points show externally calculated read counts on the curves"))
                }
                fig <- fig +
                    ylab("Unique Molecules") + 
                    ggtitle("Complexity Curve: preseq")
            }
            
            fig <- fig +
                labs(col = "") +
                scale_color_discrete(labels=c(sample_name)) +
                theme_classic(base_size=14) +
                theme(axis.line = element_line(size = 0.5)) +
                theme(panel.grid.major = element_blank(), 
                      panel.grid.minor = element_blank(),
                      panel.border = element_rect(colour = "black", fill=NA, size=0.5)) +
                theme(plot.title = element_text(hjust = 0.5))
            
            # now save the plot
            pdf(file = paste0(tools::file_path_sans_ext(output_name), ".pdf"),
                width= 9, height = 7, useDingbats=F)
            print(fig)
            invisible(dev.off())
            png(filename = paste0(tools::file_path_sans_ext(output_name), ".png"),
                width = 617, height = 480)
            print(fig)
            invisible(dev.off())
        }
    }
}


computeLimit <- function(value, ccurve_TOTAL_READS) {
    # This function returns the index of ccurve_TOTAL_READS containing the 
    # closest value to x_max
    
    if (max(ccurve_TOTAL_READS) < value) {
        message(paste0("WARNING: ", value, " is set higher than the highest ", 
                       "extrapolated point by preseq (value=",
                       max(ccurve_TOTAL_READS)))
    }
    first_point  <- 0
    middle_point <- 0
    last_point   <- length(ccurve_TOTAL_READS)
    iterations   <- 0
    while (first_point != last_point) {
        middle_point <- (first_point + last_point)/2
        middle_value <- ccurve_TOTAL_READS[middle_point]
        if (middle_value == value || iterations >= 10000) {
            return(middle_point)
        } else if (middle_value >= value) {
            last_point  <- middle_point - 1
        } else {
            first_point <- middle_point + 1
        }
        iterations <- iterations + 1
    }
    return(first_point)
}

################################################################################
# MAIN

plot_complexity_curves(ccurves = argv$ccurves,
                       more_ccurves = argv$more_ccurves,
                       coverage = argv$coverage,
                       read_length = argv$read_length,
                       real_counts_path = argv$real_counts,
                       use_unique = argv$ignore_unique,
                       output_name = argv$output_name,
                       x_min = argv$x_min, x_max = argv$x_max)
